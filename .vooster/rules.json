{
  "rules": [
    {
      "type": "prd",
      "content": "# PRD – Slack Q&A Instant Search MVP\n\n## 1. 제품 한-줄 요약\n사내 슬랙 대화를 임베딩·검색·요약하여 스타트업 개발자/PM이 몇 초 만에 과거 해결책을 찾도록 돕는 브라우저 기반 웹 애플리케이션.\n\n## 2. 문제(Pain Point)\n슬랙 기본 검색은 정확도가 낮고 긴 스레드를 일일이 살펴봐야 해 해결책을 찾는 데 시간이 오래 걸린다.\n\n## 3. 목표(Goal)\n사용자가 **최소한의 시간으로 정확한 기술 해결책**을 찾도록 한다.\n\n### 핵심 KPI\n|지표|목표|\n|---|---|\n|첫 검색-응답까지 소요 시간|≤ 5초|\n|사용자가 원하는 해결책을 3회 이내 검색으로 찾은 비율|≥ 80%|\n|MVP 도입 후 주간 활성 사용자(WAU)|팀 인원 대비 ≥ 60%|\n\n## 4. 핵심 사용자(Persona)\n스타트업의 개발자/PM – 빠른 의사결정과 기술 문제 해결을 위해 슬랙을 주 검색 도구로 사용하지만, 기본 검색 정확도에 불만이 많음.\n\n## 5. 핵심 시나리오(Use Case)\n\"과거 Q&A 대화에서 기술 해결책을 찾기 위해 자연어 질문을 입력한다 → 즉시 요약 답변과 근거 메시지를 확인한다.\"\n\n## 6. 주요 기능 (MVP)\n1. **슬랙 데이터 임포트 & 자동 파싱** – Workspace export JSON 업로드 후 role·text·ts 추출.\n2. **OpenAI 임베딩 생성 & 벡터 DB 저장** – 메시지를 1,000토큰 이하로 분할 후 Chroma에 저장.\n3. **자연어 질문 입력 & 답변 API** – FastAPI 엔드포인트가 Chroma 검색 → ChatCompletion 호출 → 답변+근거 반환.\n4. **간단한 웹 UI** – Streamlit 기반 검색창, 답변 박스, 근거 토글.\n\n## 7. 부가기능 (MVP+1 베타)\nC. 주기적 재인덱싱 스케줄링  \nE. Dockerfile & 원클릭 배포 스크립트  \nG. 세련된 UI/다크·라이트 테마\n\n## 8. 범위에서 제외 (Non-Goals)\n- 자동 슬랙 OAuth 동기화\n- 멀티-워크스페이스 관리 UI\n- 모바일 네이티브 앱\n- 고급 권한관리, 다중 사용자 계정 시스템\n\n## 9. 개발 전략\n린 스타트업 방식 – **6시간 이내 초소형 MVP** 완성 → 실사용 피드백 → 1-2주 간격 기능 확장.\n\n## 10. 일정(6h 해킹 세션)\n|단계|시간|담당|\n|---|---|---|\n|1. 데이터 준비|1h|BE 1|\n|2. 임베딩 & 벡터 DB|1.5h|BE 1|\n|3. 질의 API|1h|BE 1|\n|4. 프론트엔드 UI|2h|FE 2|\n|5. 통합 & 시연|0.5h|ALL|\n\n## 11. 리스크 & 완화책\n- **OpenAI Rate Limit** → 메시지 배치·지수적 backoff 적용\n- **대용량 데이터 시 인덱싱 지연** → 메시지를 청크 분할, 진척도 프로그레스바 표시\n- **프롬프트 품질** → 템플릿 버전 관리 및 A/B 테스트\n\n## 12. 성공 정의 (Success Criteria)\n- 베타 팀에서 \"슬랙 기본 검색보다 낫다\"는 피드백 ≥ 80%\n- 도입 후 한 주 내 검색 30회 이상\n\n---\n본 PRD는 Vooster에 저장되었습니다. `Create Project` 버튼을 눌러 진행해 주세요.",
      "writedAt": "2025-08-20T02:53:48.254Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD)\n\n## 1. Executive Technical Summary\n- **Project Overview**: 사내 슬랙 대화 내용을 검색하고 요약하여 개발자/PM이 기술 문제 해결책을 빠르게 찾을 수 있도록 지원하는 웹 애플리케이션을 개발합니다. Slack 데이터 임포트, OpenAI 임베딩 생성, 벡터 DB 저장, 자연어 질문 입력 및 답변 API, 간단한 웹 UI를 구현합니다.\n- **Core Technology Stack**: Python 3.11, FastAPI, ChromaDB, OpenAI embeddings, Streamlit을 사용하여 빠르고 효율적인 MVP를 구축합니다.\n- **Key Technical Objectives**: 첫 검색-응답까지 소요 시간 ≤ 5초, 사용자가 원하는 해결책을 3회 이내 검색으로 찾은 비율 ≥ 80%, MVP 도입 후 주간 활성 사용자(WAU) 팀 인원 대비 ≥ 60%를 달성합니다.\n- **Critical Technical Assumptions**: OpenAI API의 안정적인 사용 가능, ChromaDB의 효율적인 벡터 검색 성능, 슬랙 export JSON 파일의 표준 형식 준수를 가정합니다.\n\n## 2. Tech Stack\n\n| Category          | Technology / Library        | Reasoning (Why it's chosen for this project) |\n| ----------------- | --------------------------- | -------------------------------------------- |\n| 언어              | Python 3.11                 | 생산성, 풍부한 라이브러리 생태계, 머신러닝/API 개발에 적합 |\n| 웹 프레임워크      | FastAPI                     | 빠른 API 개발, 자동 문서화, 비동기 처리 지원 |\n| 벡터 데이터베이스   | ChromaDB                    | 임베딩 저장 및 유사도 검색에 최적화, 간편한 사용 |\n| 임베딩 모델       | OpenAI embeddings           | 높은 품질의 임베딩 제공, 다양한 텍스트 처리 작업 지원 |\n| UI 프레임워크      | Streamlit                   | 간단하고 빠른 웹 UI 개발, 데이터 시각화에 용이 |\n| 자연어 처리       | OpenAI API (ChatCompletion) | 질문에 대한 요약 답변 생성, 자연스러운 텍스트 생성 |\n| 데이터 처리        | Pandas                      | 슬랙 데이터 파싱 및 전처리 |\n\n## 3. System Architecture Design\n\n### Top-Level building blocks\n- **Frontend (Streamlit UI)**:\n    - 사용자 인터페이스 제공\n    - 검색어 입력 및 결과 표시\n    - 슬랙 데이터 업로드 처리\n    - 다크/라이트 모드 전환 (MVP+1)\n- **Backend (FastAPI API)**:\n    - API 엔드포인트 정의 및 관리\n    - 슬랙 데이터 파싱 및 전처리 로직\n    - OpenAI 임베딩 생성 및 ChromaDB 저장 로직\n    - 검색어 기반 ChromaDB 검색 및 결과 요약\n    - OpenAI API 호출 및 결과 반환\n- **Vector Database (ChromaDB)**:\n    - 슬랙 메시지 임베딩 저장\n    - 유사도 검색 기능 제공\n- **OpenAI API**:\n    - 텍스트 임베딩 생성 (embeddings)\n    - 질문에 대한 요약 답변 생성 (ChatCompletion)\n\n### Top-Level Component Interaction Diagram\n\n```mermaid\ngraph TD\n    A[Streamlit UI] --> B[FastAPI API]\n    B --> C[ChromaDB]\n    B --> D[OpenAI API]\n```\n\n- **Frontend (Streamlit UI)**: 사용자의 검색어 입력을 받아 Backend (FastAPI API)로 전달하고, Backend에서 받은 검색 결과를 화면에 표시합니다.\n- **Backend (FastAPI API)**: Frontend로부터 검색어 요청을 받아 ChromaDB에서 유사한 메시지를 검색하고, OpenAI API를 사용하여 요약 답변을 생성합니다.\n- **Vector Database (ChromaDB)**: 슬랙 메시지 임베딩을 저장하고, Backend의 요청에 따라 유사도 검색을 수행합니다.\n- **OpenAI API**: Backend의 요청에 따라 텍스트 임베딩을 생성하거나, 질문에 대한 요약 답변을 생성합니다.\n\n### Code Organization & Convention\n**Domain-Driven Organization Strategy**\n- **Domain Separation**: 슬랙 데이터 처리, 임베딩 생성, 검색, UI 등 각 도메인별로 분리\n- **Layer-Based Architecture**: API 엔드포인트 (presentation), 비즈니스 로직 (business logic), 데이터 접근 (data access), OpenAI API 호출 (infrastructure) 레이어 분리\n- **Feature-Based Modules**: 검색 기능, 데이터 업로드 기능, UI 테마 기능 등 기능별 모듈화\n- **Shared Components**: 공통 유틸리티 함수, 데이터 타입 정의 등을 shared 모듈에 저장\n\n**Universal File & Folder Structure**\n```\n/\n├── app/                      # FastAPI 애플리케이션\n│   ├── api/                  # API 엔드포인트 정의\n│   │   ├── endpoints.py      # API 엔드포인트 함수\n│   ├── core/                 # 핵심 로직 및 설정\n│   │   ├── config.py         # 설정 파일\n│   │   ├── database.py       # 데이터베이스 연결\n│   ├── services/             # 비즈니스 로직\n│   │   ├── slack_data.py     # 슬랙 데이터 처리\n│   │   ├── embedding.py      # 임베딩 생성 및 저장\n│   │   ├── search.py         # 검색 로직\n│   │   ├── openai_api.py     # OpenAI API 호출\n│   ├── models/               # 데이터 모델 정의\n│   │   ├── message.py        # 메시지 모델\n│   ├── main.py               # FastAPI 애플리케이션 시작점\n├── streamlit_app/          # Streamlit UI 애플리케이션\n│   ├── ui.py               # UI 구성 요소\n│   ├── utils.py            # UI 유틸리티 함수\n│   ├── main.py               # Streamlit 애플리케이션 시작점\n├── scripts/                # 스크립트\n│   ├── data_import.py      # 데이터 임포트 스크립트\n├── Dockerfile                # Dockerfile (MVP+1)\n├── README.md                # README 파일\n├── requirements.txt        # Python 의존성 목록\n```\n\n### Data Flow & Communication Patterns\n- **Client-Server Communication**: Streamlit UI (client)가 FastAPI API (server)로 HTTP 요청을 보내고, API는 JSON 형식으로 응답합니다.\n- **Database Interaction**: FastAPI API는 ChromaDB에 저장된 임베딩을 검색하기 위해 ChromaDB API를 사용합니다.\n- **External Service Integration**: FastAPI API는 OpenAI API를 사용하여 텍스트 임베딩을 생성하고, 질문에 대한 요약 답변을 생성합니다.\n- **Data Synchronization**: 데이터 일관성을 위해 ChromaDB에 저장된 임베딩은 슬랙 데이터가 업데이트될 때마다 재인덱싱됩니다.\n\n## 4. Performance & Optimization Strategy\n- **OpenAI API Rate Limit**: 메시지를 배치로 처리하고, 지수적 backoff를 적용하여 API 호출 횟수를 줄입니다.\n- **대용량 데이터 인덱싱 지연**: 메시지를 청크 단위로 분할하여 인덱싱하고, 진행 상황을 사용자에게 시각적으로 표시합니다.\n- **ChromaDB 검색 성능**: ChromaDB 인덱싱 최적화 및 적절한 검색 파라미터 설정으로 검색 속도를 향상시킵니다.\n- **FastAPI 캐싱**: 자주 사용되는 API 응답을 캐싱하여 응답 시간을 단축합니다.\n\n## 5. Implementation Roadmap & Milestones\n### Phase 1: Foundation (MVP Implementation)\n- **Core Infrastructure**: FastAPI API 및 Streamlit UI 기본 구조 설정, ChromaDB 연동\n- **Essential Features**: 슬랙 데이터 임포트, 임베딩 생성 및 저장, 자연어 질문 입력 및 답변 API, 간단한 웹 UI\n- **Basic Security**: API 엔드포인트에 대한 기본적인 인증 및 권한 관리\n- **Development Setup**: 개발 환경 설정 및 CI/CD 기본 설정\n- **Timeline**: 6시간 (해킹 세션)\n\n### Phase 2: Feature Enhancement\n- **Advanced Features**: 주기적 재인덱싱 스케줄링, Dockerfile 및 원클릭 배포 스크립트, 세련된 UI/다크·라이트 테마\n- **Performance Optimization**: ChromaDB 검색 성능 최적화, FastAPI 캐싱 적용\n- **Enhanced Security**: API 보안 강화, 데이터 암호화\n- **Monitoring Implementation**: 시스템 모니터링 및 로깅 설정\n- **Timeline**: 1-2주\n\n## 6. Risk Assessment & Mitigation Strategies\n### Technical Risk Analysis\n- **Technology Risks**: OpenAI API의 불안정성 및 ChromaDB 성능 문제\n    - **Mitigation Strategies**: OpenAI API 에러 처리 및 재시도 로직 구현, ChromaDB 성능 모니터링 및 튜닝\n- **Performance Risks**: 대용량 데이터 처리 시 인덱싱 지연 및 검색 속도 저하\n    - **Mitigation Strategies**: 데이터 청크 분할, 인덱싱 최적화, 캐싱 적용\n- **Security Risks**: API 엔드포인트에 대한 무단 접근 및 데이터 유출\n    - **Mitigation Strategies**: API 인증 및 권한 관리 강화, 데이터 암호화\n- **Integration Risks**: OpenAI API 및 ChromaDB와의 호환성 문제\n    - **Mitigation Strategies**: API 버전 관리 및 호환성 테스트\n\n### Project Delivery Risks\n- **Timeline Risks**: 개발 일정 지연 및 예상치 못한 문제 발생\n    - **Contingency Plans**: 우선순위가 낮은 기능 축소, 외부 라이브러리 활용\n- **Resource Risks**: 개발 인력 부족 및 기술적 어려움\n    - **Contingency Plans**: 팀원 간 협업 강화, 외부 전문가 자문\n- **Quality Risks**: 코드 품질 저하 및 버그 발생\n    - **Contingency Plans**: 코드 리뷰 강화, 자동화된 테스트 구축\n- **Deployment Risks**: 배포 환경 문제 및 시스템 장애\n    - **Contingency Plans**: 배포 자동화, 롤백 전략 수립\n",
      "writedAt": "2025-08-20T02:53:48.254Z"
    },
    {
      "type": "guideline",
      "content": "# Code Guideline: Slack Q&A Instant Search MVP\n\n## 1. Project Overview\n\nThis project aims to build a web application that allows developers and PMs to quickly find technical solutions from internal Slack conversations. It involves importing Slack data, generating OpenAI embeddings, storing them in ChromaDB, providing a natural language question input and answer API, and a simple web UI. The core technologies used are Python 3.11, FastAPI, ChromaDB, OpenAI embeddings, and Streamlit.\n\nKey architectural decisions include:\n- A layered architecture with separation of concerns (API, business logic, data access, infrastructure).\n- Domain-driven organization, separating Slack data processing, embedding generation, search, and UI into distinct modules.\n- Feature-based modules for search, data upload, and UI themes.\n\n## 2. Core Principles\n\n- **Readability**: Code should be easy to understand and maintain.\n- **Efficiency**: Code should be optimized for performance and resource utilization.\n- **Testability**: Code should be designed to facilitate unit and integration testing.\n- **Modularity**: Code should be broken down into reusable components.\n- **Consistency**: Code should adhere to a consistent style and structure.\n\n## 3. Language-Specific Guidelines\n\n### Python\n\n#### File Organization and Directory Structure\n\n-   Follow the defined file and folder structure in the TRD.\n-   Each module should have a clear purpose and responsibility.\n-   Use descriptive filenames.\n\n#### Import/Dependency Management\n\n-   Use `requirements.txt` for managing dependencies.\n-   Use absolute imports for project modules and relative imports within the same package.\n-   Sort imports alphabetically within each group (standard library, third-party, local).\n\n```python\n# MUST: Correct import style\nimport os\nimport sys\n\nimport pandas as pd\nfrom chromadb import Client\n\nfrom app.core import config\nfrom app.services import embedding\n```\n\n```python\n# MUST NOT: Avoid wildcard imports\n# Reason: Makes it difficult to track dependencies and can lead to namespace collisions.\nfrom app.core import *\n```\n\n#### Error Handling Patterns\n\n-   Use `try...except` blocks for handling potential exceptions.\n-   Log exceptions with sufficient context.\n-   Raise specific exceptions when appropriate.\n-   Avoid bare `except` clauses.\n\n```python\n# MUST: Proper error handling\ntry:\n    result = some_function()\nexcept ValueError as e:\n    logger.error(f\"ValueError occurred: {e}\")\n    raise  # Re-raise if the error cannot be handled\nexcept Exception as e:\n    logger.exception(\"Unexpected error occurred\") # Log the full traceback\n    return None # Or handle gracefully\n```\n\n```python\n# MUST NOT: Bare except clause\n# Reason: Catches all exceptions, making debugging difficult and potentially masking critical errors.\ntry:\n    result = some_function()\nexcept:\n    print(\"An error occurred\")\n```\n\n### FastAPI\n\n#### File Organization\n\n- Follow the directory structure defined in the TRD.\n- Use separate modules for different API endpoints.\n\n#### Dependency Injection\n- Use FastAPI's dependency injection system for managing dependencies.\n- Define dependencies as functions with type hints.\n\n```python\n# MUST: Using dependency injection\nfrom fastapi import Depends, FastAPI\n\napp = FastAPI()\n\ndef get_db():\n    db = DatabaseSession()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: int, db: DatabaseSession = Depends(get_db)):\n    item = db.query(Item).get(item_id)\n    return item\n```\n\n#### Response Models\n\n- Use Pydantic models for defining request and response bodies.\n- Ensure response models accurately reflect the data being returned.\n\n```python\n# MUST: Using Pydantic models\nfrom pydantic import BaseModel\n\nclass Message(BaseModel):\n    text: str\n    role: str\n    ts: str\n\nfrom typing import List\nclass ResponseModel(BaseModel):\n    results: List[Message]\n\n@app.post(\"/search\", response_model=ResponseModel)\nasync def search(query: str):\n    # ... search logic ...\n    return ResponseModel(results=[...])\n```\n\n### Streamlit\n\n#### File Organization\n\n- Separate UI components into reusable functions.\n- Use a main file to orchestrate the UI.\n\n#### State Management\n\n- Use Streamlit's `st.session_state` for managing state.\n- Avoid directly modifying session state variables.\n\n```python\n# MUST: Using st.session_state\nimport streamlit as st\n\nif 'counter' not in st.session_state:\n    st.session_state['counter'] = 0\n\ndef increment_counter():\n    st.session_state['counter'] += 1\n\nst.button('Increment', on_click=increment_counter)\nst.write(f\"Counter: {st.session_state['counter']}\")\n```\n\n#### UI Components\n\n- Use Streamlit's built-in UI components.\n- Customize UI components using CSS or JavaScript if necessary.\n\n## 4. Code Style Rules\n\n### MUST Follow:\n\n-   **PEP 8 Compliance**: Adhere to PEP 8 style guidelines for Python code.\n    *   Rationale: Improves readability and consistency.\n    *   Implementation: Use a linter (e.g., `flake8`, `pylint`) to enforce PEP 8.\n-   **Descriptive Naming**: Use clear and descriptive names for variables, functions, and classes.\n    *   Rationale: Makes code easier to understand and maintain.\n    *   Implementation: Choose names that accurately reflect the purpose of the element.\n-   **Docstrings**: Write docstrings for all functions, classes, and modules.\n    *   Rationale: Provides documentation and helps with code understanding.\n    *   Implementation: Use reStructuredText or Google-style docstrings.\n-   **Type Hints**: Use type hints for function arguments and return values.\n    *   Rationale: Improves code readability and helps with static analysis.\n    *   Implementation: Add type hints to function signatures (e.g., `def add(x: int, y: int) -> int:`).\n-   **Logging**: Use the `logging` module for logging events.\n    *   Rationale: Provides a structured way to record events and debug issues.\n    *   Implementation: Configure a logger and use it to log events at appropriate levels (e.g., `INFO`, `WARNING`, `ERROR`).\n-   **Unit Tests**: Write unit tests for all critical functionality.\n    *   Rationale: Ensures code correctness and prevents regressions.\n    *   Implementation: Use `pytest` or `unittest` to write and run tests.\n-   **Asynchronous Programming**: Use `async` and `await` for I/O-bound operations.\n    *   Rationale: Improves application performance and responsiveness.\n    *   Implementation: Use `async def` to define asynchronous functions and `await` to call them.\n-   **Consistent Formatting**: Use a code formatter (e.g., `black`) to ensure consistent code formatting.\n    *   Rationale: Improves code readability and reduces style-related debates.\n    *   Implementation: Configure a code formatter and run it automatically on every commit.\n\n```python\n# MUST: Proper docstring example\ndef process_data(data: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"Processes the input data by cleaning and transforming it.\n\n    Args:\n        data: A Pandas DataFrame containing the data to process.\n\n    Returns:\n        A Pandas DataFrame containing the processed data.\n    \"\"\"\n    # ... processing logic ...\n    return processed_data\n```\n\n### MUST NOT Do:\n\n-   **Code Duplication**: Avoid duplicating code.\n    *   Rationale: Makes code harder to maintain and increases the risk of errors.\n    *   Implementation: Extract common logic into reusable functions or classes.\n-   **Hardcoded Values**: Avoid hardcoding values in the code.\n    *   Rationale: Makes code less flexible and harder to configure.\n    *   Implementation: Use configuration files or environment variables to store values.\n-   **Long Functions**: Avoid writing long functions.\n    *   Rationale: Makes code harder to understand and maintain.\n    *   Implementation: Break down long functions into smaller, more manageable functions.\n-   **Nested Conditional Statements**: Avoid deeply nested conditional statements.\n    *   Rationale: Makes code harder to read and understand.\n    *   Implementation: Use guard clauses or refactor the code to reduce nesting.\n-   **Ignoring Errors**: Avoid ignoring errors without handling them.\n    *   Rationale: Can lead to unexpected behavior and make debugging difficult.\n    *   Implementation: Handle errors gracefully and log them appropriately.\n-   **Over-Engineering**: Avoid over-engineering solutions.\n    *   Rationale: Can lead to unnecessary complexity and increased development time.\n    *   Implementation: Keep solutions simple and focused on the core requirements.\n-   **Unnecessary Comments**: Avoid writing obvious or redundant comments.\n    *   Rationale: Clutters the code and makes it harder to read.\n    *   Implementation: Write comments only when necessary to explain complex logic or non-obvious behavior.\n-   **Global Variables**: Avoid using global variables.\n    *   Rationale: Makes code harder to reason about and can lead to unexpected side effects.\n    *   Implementation: Use dependency injection or pass data explicitly between functions.\n-   **Complex State Management**: Avoid overly complex state management patterns for this MVP.\n    * Rationale: Adds unnecessary overhead and complexity. Streamlit's `st.session_state` is sufficient.\n-   **Huge, Multi-Responsibility Modules**: Avoid creating single files with excessive lines of code and multiple responsibilities.\n    * Rationale: Reduces maintainability and makes it difficult to understand the module's purpose.\n\n```python\n# MUST NOT: Hardcoding values\n# Reason: Makes the code inflexible and difficult to configure.\ndef connect_to_database():\n    host = \"localhost\"  # Hardcoded host\n    port = 5432         # Hardcoded port\n    # ...\n```\n\n```python\n# MUST NOT: Ignoring Errors\n# Reason: Hides potential issues and makes debugging difficult.\ntry:\n    result = some_operation()\nexcept Exception:\n    pass  # Ignoring the error\n```\n\n## 5. Architecture Patterns\n\n### Component/Module Structure Guidelines\n\n-   **Layered Architecture**: Separate the application into layers (API, business logic, data access, infrastructure).\n-   **Domain-Driven Design**: Organize code around domain concepts (e.g., Slack data, embeddings, search).\n-   **Feature-Based Modules**: Group code by features (e.g., search, data upload, UI themes).\n-   **Shared Components**: Store common utilities and data types in a shared module.\n\n### Data Flow Patterns\n\n-   **Client-Server Communication**: Use HTTP requests and JSON responses for communication between the Streamlit UI and the FastAPI API.\n-   **Database Interaction**: Use ChromaDB's API to interact with the vector database.\n-   **External Service Integration**: Use OpenAI's API to generate embeddings and summarize answers.\n-   **Data Synchronization**: Re-index embeddings in ChromaDB whenever Slack data is updated.\n\n### State Management Conventions\n\n-   Use Streamlit's `st.session_state` for managing UI state.\n-   Avoid complex state management patterns for this MVP.\n\n### API Design Standards\n\n-   **RESTful API**: Design APIs following RESTful principles.\n-   **JSON Format**: Use JSON for request and response bodies.\n-   **Descriptive Endpoints**: Use clear and descriptive endpoint names.\n-   **Pydantic Models**: Use Pydantic models for request and response validation.\n-   **Error Handling**: Return appropriate HTTP status codes for errors.\n-   **Asynchronous Operations**: Use asynchronous operations for I/O-bound tasks.\n\n```python\n# MUST: Example of a RESTful API endpoint\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/messages/{message_id}\")\nasync def get_message(message_id: int):\n    \"\"\"Retrieves a message by its ID.\"\"\"\n    # ... logic to retrieve message from database ...\n    return {\"message\": \"example message\"}\n```\n",
      "writedAt": "2025-08-20T02:53:48.254Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-08-20T02:53:48.254Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-08-20T02:53:48.254Z"
    }
  ]
}